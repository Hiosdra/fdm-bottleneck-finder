<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Printer Speed Bottleneck Finder</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Custom styles for range input to match the Voron Design theme */
        :root {
            --color-primary: #ff0213;
            --color-track: #475569;
            --voron-dark-bg: #23272a;
            --voron-card-bg: #2c2f33;
        }
        
        .voron-card {
            background-color: var(--voron-dark-bg);
        }
        
        /* Update focus rings to use Voron red */
        input:focus, select:focus {
            outline: 2px solid #ff0213;
            outline-offset: 2px;
            border-color: #ff0213 !important;
        }
        
        /* Update hover states */
        input:hover, select:hover {
            border-color: rgba(255, 2, 19, 0.5) !important;
        }
        
        /* Reset button hover */
        .reset-btn:hover {
            color: #ff0213 !important;
        }
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--color-primary);
            margin-top: -6px;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--color-track);
            border-radius: 2px;
        }
        .gauge-circle {
            transition: stroke-dasharray 0.5s ease-out;
        }
    </style>
</head>
<body class="font-sans text-slate-100 min-h-screen p-4 md:p-8" style="background-color: #2c2f33;">

    <div class="max-w-7xl mx-auto">
        
        <!-- Header -->
        <header class="mb-8 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
                <h1 class="text-3xl font-bold text-slate-100 flex items-center gap-3">
                    <i data-lucide="activity" style="color: #ff0213;"></i>
                    3D Printer Bottleneck Finder
                </h1>
                <p class="text-slate-300 mt-2 max-w-2xl text-sm md:text-base">
                    Simulate acceleration physics and volumetric flow to find your true printing limits.
                </p>
            </div>
            <div class="flex items-center gap-2">
                <button onclick="resetConfig()" class="reset-btn text-sm text-slate-400 underline decoration-dotted transition-colors">
                    Reset to Defaults
                </button>
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <!-- LEFT COLUMN: Inputs -->
            <div class="lg:col-span-4 space-y-4 h-fit">
                
                <!-- Preset Selector -->
                <div class="voron-card p-4 rounded-xl border" style="border-color: rgba(255, 2, 19, 0.3);">
                    <div class="flex items-center gap-2 mb-3 font-semibold text-sm uppercase tracking-wide" style="color: #ff3341;">
                        <i data-lucide="printer" width="16"></i> Load Preset
                    </div>
                    <select id="preset-selector" onchange="loadPreset(this.value)" class="w-full p-2 bg-slate-700 border border-slate-600 rounded-lg text-slate-200 text-sm focus:outline-none focus:ring-2 focus:ring-red-500 cursor-pointer">
                        <option value="" disabled selected>Select a printer profile...</option>
                        <option value="ender3">Ender 3 (Standard)</option>
                        <option value="prusamk4">Prusa MK4</option>
                        <option value="bambux1c">Bambu Lab X1C</option>
                        <option value="voron24">Voron 2.4 (High Flow)</option>
                        <option value="k1">Creality K1 / Max</option>
                    </select>
                </div>

                <div id="input-container" class="space-y-4">
                    <!-- Inputs will be injected here by JS -->
                </div>
            </div>

            <!-- RIGHT COLUMN: Visualization -->
            <div class="lg:col-span-8 space-y-6">
                
                <!-- Graph Section -->
                <div class="voron-card p-6 rounded-xl shadow-sm border border-slate-700">
                    <div class="flex justify-between items-center mb-6">
                        <div class="flex gap-4">
                            <button onclick="setGraphMode('speed')" id="btn-mode-speed" class="px-3 py-1 rounded-full text-sm font-medium transition-colors text-white" style="background-color: #ff0213;">
                                Speed (mm/s)
                            </button>
                            <button onclick="setGraphMode('flow')" id="btn-mode-flow" class="px-3 py-1 rounded-full text-sm font-medium transition-colors text-slate-400 hover:bg-slate-700">
                                Flow (mm³/s)
                            </button>
                        </div>
                        <div id="speed-legend" class="flex items-center gap-2 text-sm text-slate-400">
                            <span class="w-8 h-0.5 border-t border-dashed inline-block" style="border-color: #ff0213; background-color: #ff0213;"></span> Max Volumetric Cap
                        </div>
                    </div>
                    
                    <div class="h-[350px] w-full relative">
                        <canvas id="bottleneckChart"></canvas>
                    </div>
                </div>

                <!-- Insight Cards Container -->
                <div id="insight-cards-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Cards injected by JS -->
                </div>

                <!-- Benchy Simulation Section -->
                <div class="voron-card text-white p-6 rounded-xl shadow-lg border border-slate-700">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4 border-b border-slate-700 pb-6">
                        <div>
                            <h3 class="font-bold text-xl flex items-center gap-2">
                                <i data-lucide="ship" class="w-5 h-5"></i>
                                Benchy Print Simulation
                            </h3>
                            <p class="text-slate-400 text-sm">Based on simulated Benchy move data. All moves were grouped in 5mm length groups with ceiling rounding, so specified time does not represent real Benchy exactly.</p>
                        </div>
                    </div>

                    <div id="benchy-simulation-content">
                        <!-- Benchy simulation results injected here -->
                    </div>
                </div>

                <!-- Deep Analysis Section -->
                <div class="voron-card text-white p-6 rounded-xl shadow-lg border border-slate-700">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 gap-4 border-b border-slate-700 pb-6">
                        <div>
                            <h3 class="font-bold text-xl flex items-center gap-2">
                                <i data-lucide="gauge" class="w-5 h-5"></i>
                                Deep Move Analysis
                            </h3>
                            <p class="text-slate-400 text-sm">Analyze efficiency for a specific line length.</p>
                        </div>
                        <div class="flex items-center gap-4 bg-slate-700 p-2 rounded-lg w-full md:w-auto">
                            <span id="analysis-length-display" class="text-sm font-mono w-16"></span>
                            <input 
                                type="range" 
                                min="5" 
                                max="200" 
                                step="5"
                                value="50" 
                                id="analysis-slider"
                                class="w-full md:w-48 cursor-pointer"
                                style="accent-color: #ff0213;"
                            >
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8" id="analysis-content">
                        <!-- Detailed analysis injected here -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="mt-12 py-6 border-t" style="border-color: rgba(255, 2, 19, 0.2);">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4 text-sm text-slate-400">
                <div class="flex items-center gap-2">
                    <span>Licensed under</span>
                    <a href="https://github.com/Hiosdra/fdm-bottleneck-finder/blob/main/LICENSE" 
                       target="_blank" 
                       rel="noopener noreferrer"
                       class="text-slate-300 hover:text-red-400 transition-colors underline decoration-dotted">
                        GPL-3.0
                    </a>
                </div>
                <div class="flex items-center gap-2">
                    <i data-lucide="github" width="16" class="text-slate-500"></i>
                    <a href="https://github.com/Hiosdra/fdm-bottleneck-finder" 
                       target="_blank" 
                       rel="noopener noreferrer"
                       class="text-slate-300 hover:text-red-400 transition-colors">
                        View on GitHub
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        // --- Theme Colors ---
        const THEME_COLORS = {
            // Primary colors - Voron Design theme
            primary: '#ff0213',      // Voron red
            primaryLight: '#ff3341', // Lighter Voron red
            secondary: '#268bd2',    // Voron blue (from syntax highlighting)
            secondaryLight: '#60A5FA', // blue-400
            accent: '#859900',       // Voron green (from syntax highlighting)
            
            // Chart colors
            chartLimit: '#ff0213',   // Voron red
            chartTravel: '#A855F7',  // purple-500 (Travel)
            
            // Status colors
            warning: '#f59e0b',      // amber-500
            danger: '#ff0213',       // Voron red
            success: '#859900',      // Voron green
            
            // Additional UI colors
            bridgeColor: '#f59e0b',  // amber-500
            brimColor: '#6366f1',    // indigo-500
            
            // Background colors (matching CSS variables)
            voronDarkBg: '#23272a',  // --voron-dark-bg
            voronCardBg: '#2c2f33'   // --voron-card-bg
        };

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Configuration & Defaults ---
        const defaultState = {
            config: {
                nozzleSize: 0.4,
                layerHeight: 0.2,
                lineWidth: 0.40,
                maxVolumetricSpeed: 15,
                speedInfill: 60,
                speedWall: 40,
                speedTop: 40,
                speedTravel: 150,
                accelInfill: 500,
                accelWall: 500,
                accelTop: 500,
                accelTravel: 1000,
                jerk: 8
            },
            analysisLength: 50,
            graphMode: 'speed'
        };

        // Printer Presets Library
        const printerPresets = {
            'ender3': {
                nozzleSize: 0.4, layerHeight: 0.2, lineWidth: 0.4, maxVolumetricSpeed: 12,
                speedInfill: 60, speedWall: 40, speedTop: 40, speedTravel: 150,
                accelInfill: 500, accelWall: 500, accelTop: 500, accelTravel: 1000, jerk: 8
            },
            'prusamk4': {
                nozzleSize: 0.4, layerHeight: 0.2, lineWidth: 0.45, maxVolumetricSpeed: 15,
                speedInfill: 170, speedWall: 80, speedTop: 50, speedTravel: 300,
                accelInfill: 2500, accelWall: 1000, accelTop: 800, accelTravel: 4000, jerk: 10
            },
            'bambux1c': {
                nozzleSize: 0.4, layerHeight: 0.2, lineWidth: 0.42, maxVolumetricSpeed: 24,
                speedInfill: 270, speedWall: 200, speedTop: 150, speedTravel: 500,
                accelInfill: 10000, accelWall: 5000, accelTop: 2000, accelTravel: 10000, jerk: 12
            },
            'voron24': {
                nozzleSize: 0.4, layerHeight: 0.2, lineWidth: 0.4, maxVolumetricSpeed: 24,
                speedInfill: 300, speedWall: 150, speedTop: 100, speedTravel: 500,
                accelInfill: 5000, accelWall: 3000, accelTop: 2000, accelTravel: 7000, jerk: 12
            },
             'k1': {
                nozzleSize: 0.4, layerHeight: 0.2, lineWidth: 0.42, maxVolumetricSpeed: 22,
                speedInfill: 300, speedWall: 200, speedTop: 120, speedTravel: 500,
                accelInfill: 12000, accelWall: 5000, accelTop: 2000, accelTravel: 10000, jerk: 15
            }
        };

        // --- State Management ---
        let state = JSON.parse(JSON.stringify(defaultState));
        let chartInstance = null;
        let benchyData = []; // Will hold loaded benchy CSV data

        // --- DOM Elements ---
        const inputContainer = document.getElementById('input-container');
        const insightContainer = document.getElementById('insight-cards-container');
        const analysisContent = document.getElementById('analysis-content');
        const analysisSlider = document.getElementById('analysis-slider');
        const analysisLengthDisplay = document.getElementById('analysis-length-display');
        const btnSpeed = document.getElementById('btn-mode-speed');
        const btnFlow = document.getElementById('btn-mode-flow');
        const speedLegend = document.getElementById('speed-legend');
        const benchySimulationContent = document.getElementById('benchy-simulation-content');

        // --- Benchy Data (Embedded) ---
        // Data from benchy_analysis.csv - embedded for single-file deployment
        function loadBenchyData() {
            // Embedded benchy data as JSON array
            benchyData = [
                { length: 5, extrusions: 588, type: 'Bridge' },
                { length: 10, extrusions: 113, type: 'Bridge' },
                { length: 15, extrusions: 62, type: 'Bridge' },
                { length: 20, extrusions: 72, type: 'Bridge' },
                { length: 25, extrusions: 32, type: 'Bridge' },
                { length: 30, extrusions: 3, type: 'Bridge' },
                { length: 35, extrusions: 9, type: 'Bridge' },
                { length: 5, extrusions: 42, type: 'Brim' },
                { length: 5, extrusions: 11890, type: 'Infill' },
                { length: 10, extrusions: 350, type: 'Infill' },
                { length: 15, extrusions: 259, type: 'Infill' },
                { length: 20, extrusions: 266, type: 'Infill' },
                { length: 25, extrusions: 120, type: 'Infill' },
                { length: 30, extrusions: 29, type: 'Infill' },
                { length: 5, extrusions: 512, type: 'Surface' },
                { length: 10, extrusions: 84, type: 'Surface' },
                { length: 15, extrusions: 52, type: 'Surface' },
                { length: 20, extrusions: 20, type: 'Surface' },
                { length: 25, extrusions: 10, type: 'Surface' },
                { length: 30, extrusions: 5, type: 'Surface' },
                { length: 5, extrusions: 6956, type: 'Travel' },
                { length: 10, extrusions: 526, type: 'Travel' },
                { length: 15, extrusions: 775, type: 'Travel' },
                { length: 20, extrusions: 292, type: 'Travel' },
                { length: 25, extrusions: 174, type: 'Travel' },
                { length: 30, extrusions: 93, type: 'Travel' },
                { length: 35, extrusions: 44, type: 'Travel' },
                { length: 40, extrusions: 42, type: 'Travel' },
                { length: 45, extrusions: 12, type: 'Travel' },
                { length: 50, extrusions: 6, type: 'Travel' },
                { length: 55, extrusions: 3, type: 'Travel' },
                { length: 250, extrusions: 1, type: 'Travel' },
                { length: 5, extrusions: 74059, type: 'Wall' },
                { length: 10, extrusions: 1321, type: 'Wall' },
                { length: 15, extrusions: 658, type: 'Wall' },
                { length: 20, extrusions: 382, type: 'Wall' },
                { length: 25, extrusions: 256, type: 'Wall' },
                { length: 30, extrusions: 73, type: 'Wall' }
            ];
            
            console.log(`Loaded ${benchyData.length} benchy data points (embedded)`);
        }

        // --- Benchy Simulation ---
        function simulateBenchy() {
            if (benchyData.length === 0) {
                return null;
            }

            const { config } = state;
            const area = config.layerHeight * config.lineWidth;
            const volumetricMaxSpeed = config.maxVolumetricSpeed / (area || 0.001);

            // Helper to calculate time for a single move
            // Using trapezoidal velocity profile (triangle for short moves, trapezoid for long moves)
            // Assumes symmetric acceleration/deceleration from rest to rest
            // For symmetric profile: distance to peak = length/2, using v² = 2ad gives v_reach
            const calculateMoveTime = (length, targetSpeed, accel, isTravel = false) => {
                if (accel <= 0) return 0;
                
                // Calculate max reachable speed from rest with symmetric accel/decel
                // Using kinematic equation: v² = v₀² + 2ad where v₀ = 0, d = length/2
                const v_reach = Math.sqrt(2 * accel * (length / 2));
                
                // For travel moves, no volumetric flow limit
                const v_peak = isTravel 
                    ? Math.min(targetSpeed, v_reach)
                    : Math.min(targetSpeed, volumetricMaxSpeed, v_reach);
                
                // Time to accelerate from 0 to v_peak
                const t_acc = v_peak / accel;
                
                // Distance covered during acceleration
                const d_acc = (v_peak * v_peak) / (2 * accel);
                
                // Cruise phase
                let t_cru = 0;
                if (d_acc * 2 < length) {
                    t_cru = (length - d_acc * 2) / v_peak;
                }
                
                // Total time: acceleration + cruise + deceleration
                return (t_acc * 2) + t_cru;
            };

            // Simulate all moves
            let totalTime = 0;
            const typeBreakdown = {
                'Bridge': { time: 0, count: 0 },
                'Brim': { time: 0, count: 0 },
                'Infill': { time: 0, count: 0 },
                'Surface': { time: 0, count: 0 },
                'Travel': { time: 0, count: 0 },
                'Wall': { time: 0, count: 0 }
            };

            benchyData.forEach(move => {
                let moveTime = 0;
                const count = move.extrusions;
                
                // Map move type to config
                switch (move.type) {
                    case 'Bridge':
                        // Bridges typically use slower speeds like walls
                        moveTime = calculateMoveTime(move.length, config.speedWall, config.accelWall);
                        break;
                    case 'Brim':
                        // Brim uses wall-like speeds
                        moveTime = calculateMoveTime(move.length, config.speedWall, config.accelWall);
                        break;
                    case 'Infill':
                        moveTime = calculateMoveTime(move.length, config.speedInfill, config.accelInfill);
                        break;
                    case 'Surface':
                        // Surface (top/bottom) uses top speed
                        moveTime = calculateMoveTime(move.length, config.speedTop, config.accelTop);
                        break;
                    case 'Travel':
                        moveTime = calculateMoveTime(move.length, config.speedTravel, config.accelTravel, true);
                        break;
                    case 'Wall':
                        moveTime = calculateMoveTime(move.length, config.speedWall, config.accelWall);
                        break;
                }
                
                const typeTotalTime = moveTime * count;
                totalTime += typeTotalTime;
                typeBreakdown[move.type].time += typeTotalTime;
                typeBreakdown[move.type].count += count;
            });

            // Apply empirical correction factor
            // The simulation overestimates time by ~3x due to:
            // 1. Move data grouped in 5mm buckets with ceiling rounding (adds artificial distance)
            // 2. Conservative acceleration profiles from rest to rest for each move
            // Real-world testing shows actual Benchy prints take ~1/3 of simulated time
            const BENCHY_TIME_CORRECTION = 1/3;
            totalTime *= BENCHY_TIME_CORRECTION;
            
            // Apply same correction to type breakdowns to maintain proportional accuracy
            for (const type in typeBreakdown) {
                typeBreakdown[type].time *= BENCHY_TIME_CORRECTION;
            }

            return {
                totalTime,
                typeBreakdown,
                totalMoves: benchyData.reduce((sum, m) => sum + m.extrusions, 0)
            };
        }

        // --- Benchy Recommendations ---
        function generateBenchyRecommendations(currentSimulation) {
            if (!currentSimulation) return [];

            const { config } = state;
            const recommendations = [];
            
            // Helper function to test a scenario
            const testScenario = (name, changes, icon) => {
                const oldConfig = { ...config };
                Object.assign(state.config, changes);
                const newSimulation = simulateBenchy();
                state.config = oldConfig;
                
                if (newSimulation) {
                    const timeSaved = currentSimulation.totalTime - newSimulation.totalTime;
                    const percentSaved = (timeSaved / currentSimulation.totalTime) * 100;
                    
                    // Only include recommendations with meaningful savings (>0.5%)
                    if (percentSaved > 0.5) {
                        recommendations.push({
                            name: name,
                            icon: icon,
                            timeSaved: timeSaved,
                            percentSaved: percentSaved,
                            newTime: newSimulation.totalTime,
                            changes: changes
                        });
                    }
                }
            };
            
            // Test incremental speed increases (+10%, +25%, +50%)
            [1.1, 1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `All Speeds +${percent}%`,
                    {
                        speedInfill: config.speedInfill * multiplier,
                        speedWall: config.speedWall * multiplier,
                        speedTop: config.speedTop * multiplier,
                        speedTravel: config.speedTravel * multiplier
                    },
                    'zap'
                );
            });
            
            // Test incremental acceleration increases (+10%, +25%, +50%)
            [1.1, 1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `All Accel +${percent}%`,
                    {
                        accelInfill: config.accelInfill * multiplier,
                        accelWall: config.accelWall * multiplier,
                        accelTop: config.accelTop * multiplier,
                        accelTravel: config.accelTravel * multiplier
                    },
                    'trending-up'
                );
            });
            
            // Test incremental flow increases (+10%, +25%, +50%)
            [1.1, 1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `Flow +${percent}%`,
                    {
                        maxVolumetricSpeed: config.maxVolumetricSpeed * multiplier
                    },
                    'droplet'
                );
            });
            
            // Test combinations of speed + accel
            [[1.1, 1.1], [1.25, 1.25], [1.5, 1.5]].forEach(([speedMult, accelMult]) => {
                const speedPercent = Math.round((speedMult - 1) * 100);
                const accelPercent = Math.round((accelMult - 1) * 100);
                testScenario(
                    `Speed +${speedPercent}% & Accel +${accelPercent}%`,
                    {
                        speedInfill: config.speedInfill * speedMult,
                        speedWall: config.speedWall * speedMult,
                        speedTop: config.speedTop * speedMult,
                        speedTravel: config.speedTravel * speedMult,
                        accelInfill: config.accelInfill * accelMult,
                        accelWall: config.accelWall * accelMult,
                        accelTop: config.accelTop * accelMult,
                        accelTravel: config.accelTravel * accelMult
                    },
                    'award'
                );
            });
            
            // Test combinations with flow (only +25%, not +50% as it's mostly impossible)
            [[1.25, 1.25, 1.25]].forEach(([speedMult, accelMult, flowMult]) => {
                const percent = Math.round((speedMult - 1) * 100);
                testScenario(
                    `All +${percent}% (Speed/Accel/Flow)`,
                    {
                        speedInfill: config.speedInfill * speedMult,
                        speedWall: config.speedWall * speedMult,
                        speedTop: config.speedTop * speedMult,
                        speedTravel: config.speedTravel * speedMult,
                        accelInfill: config.accelInfill * accelMult,
                        accelWall: config.accelWall * accelMult,
                        accelTop: config.accelTop * accelMult,
                        accelTravel: config.accelTravel * accelMult,
                        maxVolumetricSpeed: config.maxVolumetricSpeed * flowMult
                    },
                    'award'
                );
            });
            
            // Test per-move-type optimizations
            // Wall-specific (most time-consuming)
            [1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `Wall Speed +${percent}%`,
                    { speedWall: config.speedWall * multiplier },
                    'box'
                );
                testScenario(
                    `Wall Accel +${percent}%`,
                    { accelWall: config.accelWall * multiplier },
                    'box'
                );
                testScenario(
                    `Wall Speed & Accel +${percent}%`,
                    {
                        speedWall: config.speedWall * multiplier,
                        accelWall: config.accelWall * multiplier
                    },
                    'box'
                );
            });
            
            // Infill-specific
            [1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `Infill Speed +${percent}%`,
                    { speedInfill: config.speedInfill * multiplier },
                    'layers'
                );
                testScenario(
                    `Infill Accel +${percent}%`,
                    { accelInfill: config.accelInfill * multiplier },
                    'layers'
                );
                testScenario(
                    `Infill Speed & Accel +${percent}%`,
                    {
                        speedInfill: config.speedInfill * multiplier,
                        accelInfill: config.accelInfill * multiplier
                    },
                    'layers'
                );
            });
            
            // Travel-specific
            [1.25, 1.5].forEach(multiplier => {
                const percent = Math.round((multiplier - 1) * 100);
                testScenario(
                    `Travel Speed & Accel +${percent}%`,
                    {
                        speedTravel: config.speedTravel * multiplier,
                        accelTravel: config.accelTravel * multiplier
                    },
                    'move'
                );
            });

            // Sort by time saved (descending) and take top recommendations
            recommendations.sort((a, b) => b.timeSaved - a.timeSaved);

            return recommendations;
        }

        // --- Update Benchy Simulation Display ---
        function updateBenchySimulation() {
            if (benchyData.length === 0) {
                benchySimulationContent.innerHTML = `
                    <div class="text-center text-slate-400 py-8">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Unable to parse embedded benchy data</p>
                    </div>
                `;
                return;
            }

            const simulation = simulateBenchy();
            if (!simulation) return;

            const recommendations = generateBenchyRecommendations(simulation);

            const minutes = Math.floor(simulation.totalTime / 60);
            const seconds = Math.floor(simulation.totalTime % 60);

            // Create type breakdown HTML
            const typeBreakdownHTML = Object.entries(simulation.typeBreakdown)
                .filter(([type, data]) => data.count > 0)
                .sort((a, b) => b[1].time - a[1].time)
                .map(([type, data]) => {
                    const percent = (data.time / simulation.totalTime) * 100;
                    const mins = Math.floor(data.time / 60);
                    const secs = Math.floor(data.time % 60);
                    
                    // Color coding by type
                    const colors = {
                        'Wall': THEME_COLORS.primary,
                        'Infill': THEME_COLORS.secondary,
                        'Travel': THEME_COLORS.chartTravel,
                        'Surface': THEME_COLORS.accent,
                        'Bridge': THEME_COLORS.bridgeColor,
                        'Brim': THEME_COLORS.brimColor
                    };
                    const color = colors[type] || '#94a3b8';
                    
                    return `
                        <div class="flex items-center justify-between text-sm">
                            <div class="flex items-center gap-2 flex-1">
                                <div class="w-3 h-3 rounded" style="background-color: ${color}"></div>
                                <span class="text-slate-300">${type}</span>
                                <span class="text-slate-500 text-xs">(${data.count} moves)</span>
                            </div>
                            <div class="flex items-center gap-3">
                                <div class="w-32 bg-slate-600 rounded-full h-2 overflow-hidden">
                                    <div class="h-full rounded-full" style="width: ${percent}%; background-color: ${color}"></div>
                                </div>
                                <span class="text-slate-300 font-mono text-xs w-20 text-right">${mins}m ${secs}s</span>
                                <span class="text-slate-500 text-xs w-12 text-right">${percent.toFixed(1)}%</span>
                            </div>
                        </div>
                    `;
                }).join('');

            // Create recommendations HTML (show top 12 most effective)
            const recommendationsHTML = recommendations.slice(0, 12).map(rec => {
                const mins = Math.floor(rec.newTime / 60);
                const secs = Math.floor(rec.newTime % 60);
                const savedMins = Math.floor(rec.timeSaved / 60);
                const savedSecs = Math.floor(rec.timeSaved % 60);
                
                // Generate changes list
                const changesList = Object.entries(rec.changes).map(([key, value]) => {
                    const labels = {
                        speedInfill: 'Infill Speed',
                        speedWall: 'Wall Speed',
                        speedTop: 'Top Speed',
                        speedTravel: 'Travel Speed',
                        accelInfill: 'Infill Accel',
                        accelWall: 'Wall Accel',
                        accelTop: 'Top Accel',
                        accelTravel: 'Travel Accel',
                        maxVolumetricSpeed: 'Max Flow'
                    };
                    const label = labels[key] || key;
                    const unit = key === 'maxVolumetricSpeed' ? 'mm³/s' :
                                 key.includes('Speed') ? 'mm/s' : 
                                 key.includes('accel') ? 'mm/s²' : '';
                    return `<span class="text-xs text-slate-400">${label}: ${Math.round(value)}${unit}</span>`;
                }).join(', ');
                
                return `
                    <div class="bg-slate-700/50 p-4 rounded-xl border border-slate-600 hover:border-slate-500 transition-colors">
                        <div class="flex items-start justify-between mb-3">
                            <div class="flex items-center gap-2">
                                <i data-lucide="${rec.icon}" width="18" style="color: ${THEME_COLORS.primaryLight};"></i>
                                <h4 class="font-bold text-slate-200">${rec.name}</h4>
                            </div>
                            <div class="px-2 py-1 rounded text-xs font-bold bg-emerald-500/20 text-emerald-300">
                                -${rec.percentSaved.toFixed(1)}%
                            </div>
                        </div>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center text-sm">
                                <span class="text-slate-400">New Time:</span>
                                <span class="font-bold text-slate-200">${mins}m ${secs}s</span>
                            </div>
                            <div class="flex justify-between items-center text-sm">
                                <span class="text-slate-400">Time Saved:</span>
                                <span class="font-bold text-emerald-400">${savedMins}m ${savedSecs}s</span>
                            </div>
                            <div class="pt-2 border-t border-slate-600 text-xs text-slate-400">
                                ${changesList}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            benchySimulationContent.innerHTML = `
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                    <!-- Total Time Card -->
                    <div class="bg-gradient-to-br from-red-500/20 to-transparent p-6 rounded-xl border border-red-500/30">
                        <div class="flex items-center gap-2 text-red-300 text-sm mb-2">
                            <i data-lucide="clock" width="16"></i>
                            <span class="uppercase tracking-wider font-semibold">Total Print Time</span>
                        </div>
                        <div class="text-4xl font-bold text-white mb-1">
                            ${minutes}<span class="text-2xl text-slate-400">m</span> ${seconds}<span class="text-2xl text-slate-400">s</span>
                        </div>
                        <div class="text-sm text-slate-400">≈ ${(simulation.totalTime / 60).toFixed(1)} minutes</div>
                    </div>

                    <!-- Total Moves Card -->
                    <div class="bg-slate-700/50 p-6 rounded-xl border border-slate-600">
                        <div class="flex items-center gap-2 text-slate-400 text-sm mb-2">
                            <i data-lucide="move" width="16"></i>
                            <span class="uppercase tracking-wider font-semibold">Total Moves</span>
                        </div>
                        <div class="text-4xl font-bold text-white mb-1">${simulation.totalMoves.toLocaleString()}</div>
                        <div class="text-sm text-slate-400">Individual extrusions</div>
                    </div>

                    <!-- Slowest Type Card -->
                    <div class="bg-slate-700/50 p-6 rounded-xl border border-slate-600">
                        <div class="flex items-center gap-2 text-slate-400 text-sm mb-2">
                            <i data-lucide="alert-triangle" width="16"></i>
                            <span class="uppercase tracking-wider font-semibold">Slowest Type</span>
                        </div>
                        ${(() => {
                            const slowest = Object.entries(simulation.typeBreakdown)
                                .filter(([type, data]) => data.count > 0)
                                .sort((a, b) => b[1].time - a[1].time)[0];
                            if (slowest) {
                                const [type, data] = slowest;
                                const percent = (data.time / simulation.totalTime) * 100;
                                return `
                                    <div class="text-3xl font-bold text-white mb-1">${type}</div>
                                    <div class="text-sm text-slate-400">${percent.toFixed(1)}% of total time</div>
                                `;
                            }
                            return '<div class="text-slate-500">N/A</div>';
                        })()}
                    </div>
                </div>

                <!-- Type Breakdown -->
                <div class="bg-slate-700/30 p-6 rounded-xl border border-slate-600 mb-6">
                    <h4 class="font-bold text-slate-200 mb-4 flex items-center gap-2">
                        <i data-lucide="pie-chart" width="18" style="color: ${THEME_COLORS.primaryLight};"></i>
                        Time Breakdown by Move Type
                    </h4>
                    <div class="space-y-3">
                        ${typeBreakdownHTML}
                    </div>
                </div>

                <!-- Recommendations -->
                <div class="bg-slate-700/30 p-6 rounded-xl border border-slate-600">
                    <h4 class="font-bold text-slate-200 mb-4 flex items-center gap-2">
                        <i data-lucide="lightbulb" width="18" style="color: ${THEME_COLORS.primaryLight};"></i>
                        Recommendations to Speed Up Your Print
                    </h4>
                    <p class="text-sm text-slate-400 mb-4">
                        These upgrades show potential time savings based on your current configuration. 
                        Results assume your printer hardware can handle the increased speeds and accelerations.
                    </p>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        ${recommendationsHTML}
                    </div>
                </div>
            `;
            
            lucide.createIcons();
        }

        // --- Initialization ---
        function init() {
            // Load from LocalStorage if available
            const saved = localStorage.getItem('bottleneckFinderConfig');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Merge saved config with default structure to ensure all keys exist
                    state.config = { ...defaultState.config, ...parsed };
                } catch (e) {
                    console.error("Failed to load config", e);
                }
            }

            renderInputs();
            initChart();
            
            // Initialize analysis display
            analysisLengthDisplay.textContent = state.analysisLength + 'mm';
            analysisLengthDisplay.style.color = THEME_COLORS.primaryLight;
            
            // Load benchy data (now synchronous with embedded data)
            loadBenchyData();
            update();
            
            // Event Listeners
            analysisSlider.addEventListener('input', (e) => {
                state.analysisLength = parseInt(e.target.value);
                analysisLengthDisplay.textContent = state.analysisLength + 'mm';
                update();
            });
        }

        // --- Core Logic ---
        function loadPreset(presetKey) {
            if (printerPresets[presetKey]) {
                state.config = { ...printerPresets[presetKey] };
                saveConfig();
                renderInputs(); // Re-render inputs to show new values
                update();
            }
        }

        function resetConfig() {
            if(confirm("Reset all settings to default?")) {
                state.config = { ...defaultState.config };
                document.getElementById('preset-selector').value = "";
                saveConfig();
                renderInputs();
                update();
            }
        }

        function saveConfig() {
            localStorage.setItem('bottleneckFinderConfig', JSON.stringify(state.config));
        }

        function setGraphMode(mode) {
            state.graphMode = mode;
            if (mode === 'speed') {
                btnSpeed.className = "px-3 py-1 rounded-full text-sm font-medium transition-colors text-white";
                btnSpeed.style.backgroundColor = '#ff0213';
                btnFlow.className = "px-3 py-1 rounded-full text-sm font-medium transition-colors text-slate-400 hover:bg-slate-700";
                btnFlow.style.backgroundColor = '';
                speedLegend.style.display = 'flex';
            } else {
                btnFlow.className = "px-3 py-1 rounded-full text-sm font-medium transition-colors text-white";
                btnFlow.style.backgroundColor = '#ff0213';
                btnSpeed.className = "px-3 py-1 rounded-full text-sm font-medium transition-colors text-slate-400 hover:bg-slate-700";
                btnSpeed.style.backgroundColor = '';
                speedLegend.style.display = 'none';
            }
            update();
        }

        // --- UI Rendering: Inputs ---
        function renderInputs() {
            const groups = [
                {
                    title: "Physical Limits",
                    icon: "settings",
                    inputs: [
                        { label: "Nozzle Size", key: "nozzleSize", unit: "mm", step: 0.1 },
                        { label: "Max Vol Flow", key: "maxVolumetricSpeed", unit: "mm³/s", step: 1, tooltip: "E3D V6 ~15, Volcano ~25" },
                        { label: "Layer Height", key: "layerHeight", unit: "mm", step: 0.04 },
                        { label: "Line Width", key: "lineWidth", unit: "mm", step: 0.01 }
                    ]
                },
                {
                    title: "Slicer Speed",
                    icon: "zap",
                    inputs: [
                        { label: "Infill Speed", key: "speedInfill", unit: "mm/s" },
                        { label: "Wall Speed", key: "speedWall", unit: "mm/s" },
                        { label: "Top/Bot Speed", key: "speedTop", unit: "mm/s" },
                        { label: "Travel Speed", key: "speedTravel", unit: "mm/s" }
                    ]
                },
                {
                    title: "Kinematics",
                    icon: "trending-up",
                    inputs: [
                        { label: "Accel (Infill)", key: "accelInfill", unit: "mm/s²" },
                        { label: "Accel (Wall)", key: "accelWall", unit: "mm/s²" },
                        { label: "Accel (Top/Bot)", key: "accelTop", unit: "mm/s²" },
                        { label: "Accel (Travel)", key: "accelTravel", unit: "mm/s²" },
                        { label: "Junction Speed", key: "jerk", unit: "mm/s", tooltip: "Junction/cornering speed (related to Marlin Jerk setting). Used for junction analysis only." }
                    ]
                }
            ];

            inputContainer.innerHTML = groups.map(group => `
                <div class="voron-card p-4 rounded-xl shadow-sm border border-slate-700">
                    <div class="flex items-center gap-2 mb-4 text-slate-200 font-semibold border-b border-slate-700 pb-2">
                        <i data-lucide="${group.icon}" width="18"></i>
                        <h3>${group.title}</h3>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        ${group.inputs.map(input => `
                            <div class="flex flex-col gap-1">
                                <div class="flex justify-between items-center">
                                    <label class="text-xs font-medium text-slate-400 uppercase">${input.label}</label>
                                    ${input.tooltip ? `<div class="group relative cursor-help" title="${input.tooltip}"><i data-lucide="info" width="12" class="text-slate-500"></i></div>` : ''}
                                </div>
                                <div class="relative">
                                    <input
                                        id="input-${input.key}"
                                        type="number"
                                        value="${state.config[input.key] !== undefined ? state.config[input.key] : ''}"
                                        step="${input.step || 1}"
                                        onchange="updateConfig('${input.key}', this.value)"
                                        class="w-full p-2 pr-8 bg-slate-700 border border-slate-600 rounded focus:ring-2 focus:ring-red-500 outline-none font-mono text-sm transition-all hover:border-red-500/50 text-slate-200"
                                    />
                                    <span class="absolute right-2 top-2 text-xs text-slate-500 select-none">${input.unit}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
            
            lucide.createIcons();
        }

        window.updateConfig = (key, value) => {
            const val = parseFloat(value) || 0;
            state.config[key] = val;

            // Auto-update line width if nozzle size changes (100% match)
            if (key === 'nozzleSize') {
                const newWidth = parseFloat((val * 1.0).toFixed(2));
                state.config.lineWidth = newWidth;
                
                // Update DOM element for Line Width
                const lwInput = document.getElementById('input-lineWidth');
                if (lwInput) lwInput.value = newWidth;
            }

            saveConfig(); // Save to local storage on every change
            update();
        };

        // --- Physics Engine ---
        // Physics Model: Trapezoidal velocity profile starting from rest (v₀ = 0)
        // For each move, calculates maximum achievable speed considering:
        // 1. Target speed (user setting)
        // 2. Volumetric flow limit (hotend constraint)
        // 3. Acceleration limit (kinematics constraint for given distance)
        function calculatePhysics() {
            const { config } = state;
            const data = [];
            const lengths = Array.from({ length: 100 }, (_, i) => (i + 1) * 2);

            const area = config.layerHeight * config.lineWidth;
            const volumetricMaxSpeed = config.maxVolumetricSpeed / (area || 0.001);

            lengths.forEach(dist => {
                const calcRealSpeed = (targetSpeed, accel) => {
                    // Calculate max speed achievable from rest with given acceleration and distance
                    // Using: v² = 2ad (where d = dist/2 for symmetric accel/decel)
                    const maxReachable = Math.sqrt(2 * accel * (dist / 2));
                    const limit = Math.min(targetSpeed, volumetricMaxSpeed, maxReachable);
                    
                    let factor = 'Speed';
                    if (limit === volumetricMaxSpeed) factor = 'Volumetric Flow';
                    else if (limit === maxReachable) factor = 'Acceleration';
                    
                    return { speed: limit, factor, target: targetSpeed, maxReachable };
                };

                // Travel moves don't extrude, so they're not limited by volumetric flow
                const calcTravelSpeed = (targetSpeed, accel) => {
                    const maxReachable = Math.sqrt(2 * accel * (dist / 2));
                    const limit = Math.min(targetSpeed, maxReachable);
                    
                    let factor = 'Speed';
                    if (limit === maxReachable) factor = 'Acceleration';
                    
                    return { speed: limit, factor, target: targetSpeed, maxReachable };
                };

                const getFlow = (speed) => speed * area;

                const infill = calcRealSpeed(config.speedInfill, config.accelInfill);
                const wall = calcRealSpeed(config.speedWall, config.accelWall);
                const top = calcRealSpeed(config.speedTop, config.accelTop);
                const travel = calcTravelSpeed(config.speedTravel, config.accelTravel);

                data.push({
                    length: dist,
                    infill, wall, top, travel,
                    volumetricLimit: volumetricMaxSpeed,
                    infillFlow: getFlow(infill.speed),
                    wallFlow: getFlow(wall.speed),
                    maxFlow: config.maxVolumetricSpeed
                });
            });
            return { data, volumetricMaxSpeed, area };
        }

        function runAnalysis(calculations) {
            const { config, analysisLength } = state;
            // Find closest data point
            const point = calculations.data.find(d => d.length >= analysisLength) || calculations.data[calculations.data.length - 1];

            // Helper to simulate time for a move with given parameters
            // Uses trapezoidal velocity profile starting from rest
            const simulateTime = (a, v_target) => {
                // Safety check: ensure acceleration is positive
                if (a <= 0) return Infinity; // Invalid: zero or negative acceleration
                
                const v_limit_vol = calculations.volumetricMaxSpeed;
                const v_reach = Math.sqrt(2 * a * (analysisLength / 2));
                const v_peak = Math.min(v_target, v_limit_vol, v_reach);
                
                // Time to accelerate from 0 to v_peak: t = v/a
                const t_acc = v_peak / a;
                
                // Distance covered during acceleration: d = v²/(2a)
                const d_acc = (v_peak * v_peak) / (2 * a);

                // Calculate cruise phase
                let t_cru = 0;
                if (d_acc * 2 < analysisLength) {
                    t_cru = (analysisLength - d_acc * 2) / v_peak;
                }
                // Total time: acceleration + cruise + deceleration
                return (t_acc * 2) + t_cru;
            }

            const analyzeMove = (type, speedObj, accel) => {
                const realSpeed = speedObj.speed;
                const targetSpeed = speedObj.target;
                
                // --- Time Calcs (Standard) ---
                const totalTime = simulateTime(accel, targetSpeed);
                const idealTime = analysisLength / targetSpeed;

                // --- Jerk Sensitivity Analysis ---
                // Note: "Jerk" in 3D printing firmware is actually junction speed (minimum cornering velocity)
                // We analyze if starting from junction speed (instead of rest) would help
                // This simulates continuous printing where moves don't fully stop at corners
                const MIN_JERK_THRESHOLD = 1; // mm/s - minimum meaningful junction speed
                const jerkBenefit = config.jerk > MIN_JERK_THRESHOLD;
                let jerkSavingsPercent = 0;
                
                if (jerkBenefit && accel > 0) { // Ensure valid acceleration
                    // Simulate starting from junction speed (config.jerk) instead of rest
                    const v_limit_vol = calculations.volumetricMaxSpeed;
                    const v_reach_with_jerk = Math.sqrt(config.jerk * config.jerk + 2 * accel * (analysisLength / 2));
                    const v_peak_with_jerk = Math.min(targetSpeed, v_limit_vol, v_reach_with_jerk);
                    
                    const t_acc_jerk = (v_peak_with_jerk - config.jerk) / accel;
                    const d_acc_jerk = (v_peak_with_jerk * v_peak_with_jerk - config.jerk * config.jerk) / (2 * accel);
                    let t_cru_jerk = 0;
                    if (d_acc_jerk * 2 < analysisLength) {
                        t_cru_jerk = (analysisLength - d_acc_jerk * 2) / v_peak_with_jerk;
                    }
                    const timeWithJerk = (t_acc_jerk * 2) + t_cru_jerk;
                    
                    jerkSavingsPercent = totalTime > 0 ? (1 - timeWithJerk / totalTime) * 100 : 0;
                }

                // --- Optimizations ---
                const getOptimization = (percentage) => {
                    const ratio = 1 - percentage;
                    let tips = [];
                    const isTravel = type === 'Travel';

                    // Calculate required speed based on primary limiting factor
                    if (speedObj.factor === 'Volumetric Flow') {
                        // We need higher flow to allow higher speed
                        const v_target = realSpeed / ratio;
                        const flow_target = v_target * calculations.area;
                        tips.push({ text: `Flow > ${flow_target.toFixed(1)} mm³/s`, icon: 'droplet' });

                        // Check if other limits would block this new speed
                        if (targetSpeed < v_target) {
                             tips.push({ text: `Speed > ${Math.round(v_target)} mm/s`, icon: 'zap' });
                        }
                        const d_needed = (v_target * v_target) / (2 * accel);
                        if (d_needed * 2 > analysisLength) {
                            const a_needed = (v_target * v_target) / analysisLength;
                            tips.push({ text: `Accel > ${Math.round(a_needed)} mm/s²`, icon: 'trending-up' });
                        }

                    } else if (speedObj.factor === 'Acceleration') {
                        // We need higher acceleration to reduce time
                        const a_target = accel / (ratio * ratio);
                        tips.push({ text: `Accel > ${Math.round(a_target)} mm/s²`, icon: 'trending-up' });

                        // Check if this new acceleration hits speed/flow limits
                        const v_peak_new = Math.sqrt(2 * a_target * (analysisLength / 2));
                        
                        // Travel moves don't extrude, so skip flow recommendations
                        if (!isTravel && v_peak_new > calculations.volumetricMaxSpeed) {
                            const flow_needed = v_peak_new * calculations.area;
                            tips.push({ text: `Flow > ${flow_needed.toFixed(1)} mm³/s`, icon: 'droplet' });
                        }
                        if (v_peak_new > targetSpeed) {
                             tips.push({ text: `Speed > ${Math.round(v_peak_new)} mm/s`, icon: 'zap' });
                        }

                    } else {
                        // Speed Limited
                        const v_target = targetSpeed / ratio;
                        tips.push({ text: `Speed > ${Math.round(v_target)} mm/s`, icon: 'zap' });

                        // Travel moves don't extrude, so skip flow recommendations
                        if (!isTravel) {
                            // Check if flow supports this
                            const flow_needed = v_target * calculations.area;
                            if (flow_needed > config.maxVolumetricSpeed) {
                                tips.push({ text: `Flow > ${flow_needed.toFixed(1)} mm³/s`, icon: 'droplet' });
                            }
                        }
                         
                         // Check if accel supports this
                         const d_needed = (v_target * v_target) / (2 * accel);
                         if (d_needed * 2 > analysisLength) {
                             const a_needed = (v_target * v_target) / analysisLength;
                             tips.push({ text: `Accel > ${Math.round(a_needed)} mm/s²`, icon: 'trending-up' });
                         }
                    }
                    // Combine texts
                    return { 
                        label: `-${(percentage * 100).toFixed(0)}%`, 
                        text: tips.map(t => t.text).join(' + '), 
                        icon: tips[0].icon 
                    };
                };

                return {
                    efficiency: (realSpeed / targetSpeed) * 100,
                    realTime: totalTime,
                    idealTime: idealTime,
                    flowRate: type === 'Travel' ? 0 : realSpeed * calculations.area,
                    factor: speedObj.factor,
                    speed: realSpeed,
                    jerkSavingsPercent,
                    optimizations: [0.10, 0.25, 0.50].map(getOptimization)
                };
            };

            return {
                infill: analyzeMove('Infill', point.infill, config.accelInfill),
                wall: analyzeMove('Wall', point.wall, config.accelWall),
                travel: analyzeMove('Travel', point.travel, config.accelTravel)
            };
        }

        // --- Main Update Loop ---
        function update() {
            const calculations = calculatePhysics();
            const analysis = runAnalysis(calculations);

            updateChart(calculations);
            updateInsights(analysis);
            updateDeepAnalysis(analysis, calculations.area);
            updateBenchySimulation();
            
            lucide.createIcons();
        }

        // --- Chart Logic (Chart.js) ---
        function initChart() {
            const ctx = document.getElementById('bottleneckChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { 
                            position: 'top', 
                            labels: { 
                                usePointStyle: true,
                                color: '#cbd5e1'
                            } 
                        },
                        tooltip: { 
                            callbacks: {
                                label: (context) => {
                                    return `${context.dataset.label}: ${Math.round(context.raw)} ${state.graphMode === 'speed' ? 'mm/s' : 'mm³/s'}`;
                                }
                            },
                                backgroundColor: hexToRgba(THEME_COLORS.voronDarkBg, 0.95),
                            titleColor: '#e2e8f0',
                            bodyColor: '#cbd5e1',
                            borderColor: '#475569',
                            borderWidth: 1,
                            padding: 10,
                            displayColors: true
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Move Distance (mm)', color: '#94a3b8' },
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' }
                        },
                        y: { 
                            title: { display: true, text: 'Speed (mm/s)', color: '#94a3b8' },
                            grid: { color: '#334155' },
                            ticks: { color: '#94a3b8' },
                            beginAtZero: true
                        }
                    },
                    elements: {
                        point: { radius: 0, hitRadius: 10, hoverRadius: 4 },
                        line: { tension: 0.4 }
                    }
                }
            });
        }

        function updateChart(calculations) {
            const { data, volumetricMaxSpeed } = calculations;
            const labels = data.map(d => d.length);
            const isSpeed = state.graphMode === 'speed';
            
            chartInstance.options.scales.y.title.text = isSpeed ? 'Speed (mm/s)' : 'Flow (mm³/s)';

            if (isSpeed) {
                // Limit Line (Constant)
                const limitData = new Array(data.length).fill(volumetricMaxSpeed);
                
                chartInstance.data = {
                    labels,
                    datasets: [
                        { label: 'Flow Limit', data: limitData, borderColor: THEME_COLORS.chartLimit, borderDash: [5, 5], borderWidth: 1, pointRadius: 0, fill: false },
                        { label: 'Infill', data: data.map(d => d.infill.speed), borderColor: THEME_COLORS.primary, borderWidth: 2 },
                        { label: 'Wall', data: data.map(d => d.wall.speed), borderColor: THEME_COLORS.secondary, borderWidth: 2 },
                        { label: 'Top', data: data.map(d => d.top.speed), borderColor: THEME_COLORS.accent, borderWidth: 2 },
                        { label: 'Travel', data: data.map(d => d.travel.speed), borderColor: THEME_COLORS.chartTravel, borderWidth: 2, borderDash: [5, 5] }
                    ]
                };
            } else {
                const limitData = new Array(data.length).fill(state.config.maxVolumetricSpeed);
                
                chartInstance.data = {
                    labels,
                    datasets: [
                        { label: 'Max Flow', data: limitData, borderColor: THEME_COLORS.chartLimit, borderDash: [5, 5], borderWidth: 1, pointRadius: 0 },
                        { label: 'Infill Flow', data: data.map(d => d.infillFlow), borderColor: THEME_COLORS.primary, borderWidth: 2 },
                        { label: 'Wall Flow', data: data.map(d => d.wallFlow), borderColor: THEME_COLORS.secondary, borderWidth: 2 }
                    ]
                };
            }
            chartInstance.update('none'); // 'none' for performance
        }

        // --- Insights HTML Generation ---
        function updateInsights(analysis) {
            const createCard = (title, data, colorClass, borderColor) => `
                <div class="voron-card p-4 rounded-xl border-l-4 shadow-sm" style="border-color: ${borderColor}">
                    <div class="flex justify-between items-start mb-2">
                        <h4 class="font-bold text-slate-200">${title}</h4>
                        <span class="text-xs font-mono bg-slate-700 px-2 py-1 rounded text-slate-300">Current: ${Math.round(data.speed)}mm/s</span>
                    </div>
                    
                    <div class="text-sm text-slate-300 mb-3">
                        Limiting Factor: <strong class="text-slate-100">${data.factor}</strong>
                    </div>

                    <div class="bg-slate-700/50 rounded-lg p-3">
                        <div class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 flex items-center gap-1">
                            <i data-lucide="lightbulb" width="12" style="color: #ff3341;"></i>
                            Time Savings Strategy
                        </div>
                        <div class="space-y-2">
                            ${data.optimizations.map(opt => `
                                <div class="flex items-center justify-between text-sm">
                                    <span class="text-slate-400 font-mono text-xs w-12">${opt.label}</span>
                                    <div class="flex items-center gap-2 flex-1 justify-end">
                                        <span class="font-semibold text-slate-200 text-right">${opt.text}</span>
                                        <i data-lucide="${opt.icon}" width="14" class="text-slate-400"></i>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;

            insightContainer.innerHTML = 
                createCard("Infill Strategy", analysis.infill, "purple", THEME_COLORS.primary) +
                createCard("Wall Strategy", analysis.wall, "green", THEME_COLORS.secondary) +
                createCard("Travel Strategy", analysis.travel, "blue", THEME_COLORS.chartTravel);
        }

        // --- Deep Analysis HTML Generation ---
        function updateDeepAnalysis(analysis, area) {
            const createColumn = (title, data, icon, colorHex, badgeColorClass) => {
                const limitColorClass = data.factor === 'Acceleration' ? 'bg-amber-500/20 text-amber-300' :
                                      data.factor === 'Volumetric Flow' ? 'text-red-300' : 
                                      'text-green-300';
                const limitBgColor = data.factor === 'Volumetric Flow' ? hexToRgba(THEME_COLORS.primary, 0.2) : 
                                     data.factor === 'Acceleration' ? '' : hexToRgba(THEME_COLORS.accent, 0.2);
                const limitStyle = limitBgColor ? `background-color: ${limitBgColor};` : '';
                
                const idealPercent = (data.idealTime / Math.max(data.realTime, 0.01)) * 100;
                const lostPercent = 100 - idealPercent;

                return `
                <div class="space-y-4">
                    <div class="flex items-center gap-2 font-bold uppercase tracking-wider text-sm" style="color: ${colorHex === THEME_COLORS.primary ? THEME_COLORS.primaryLight : THEME_COLORS.secondaryLight}">
                        <i data-lucide="layers" width="16"></i> ${title} Analysis
                    </div>
                    
                    <div class="bg-slate-700/50 p-4 rounded-xl border border-slate-600 grid grid-cols-2 gap-4">
                        <div class="col-span-2 flex justify-between items-center border-b border-slate-600 pb-3 mb-1">
                            <div>
                                <div class="text-3xl font-bold">${Math.round(data.speed)} <span class="text-sm text-slate-400 font-normal">mm/s</span></div>
                                <div class="text-xs text-slate-400">Achieved Speed</div>
                            </div>
                            <div class="px-2 py-1 rounded text-xs font-bold ${limitColorClass}" style="${limitStyle}">
                                Limit: ${data.factor}
                            </div>
                        </div>

                        <!-- SVG Gauge -->
                        <div class="flex flex-col items-center">
                            <div class="flex flex-col items-center justify-center p-2">
                                <div class="relative w-20 h-20">
                                    <svg class="w-full h-full" viewBox="0 0 36 36">
                                        <path d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke="#e2e8f0" stroke-width="3" />
                                        <path class="gauge-circle" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" fill="none" stroke="${colorHex}" stroke-width="3" stroke-dasharray="${data.efficiency}, 100" />
                                    </svg>
                                    <div class="absolute inset-0 flex items-center justify-center font-bold text-sm text-slate-300">
                                        ${Math.round(data.efficiency)}%
                                    </div>
                                </div>
                                <span class="text-xs font-medium text-slate-400 mt-1">Speed Eff.</span>
                            </div>
                        </div>
                        
                        <div class="space-y-2 text-xs text-slate-300">
                            <div class="flex justify-between">
                                <span class="text-slate-400">Flow:</span>
                                <span>${data.flowRate.toFixed(1)} mm³/s</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-slate-400">Time:</span>
                                <span>${data.realTime.toFixed(2)}s</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Time Bar -->
                    <div class="bg-slate-700/30 p-4 rounded-xl border border-slate-600/50">
                        <div class="flex items-center gap-2 text-slate-400 text-xs mb-2">
                            <i data-lucide="clock" width="12"></i> Time Cost Analysis
                        </div>
                        <div class="w-full mb-3">
                            <div class="flex justify-between text-xs mb-1">
                                <span class="font-medium text-slate-400">${title} Time</span>
                                <span class="text-slate-500">${data.realTime.toFixed(3)}s total</span>
                            </div>
                            <div class="h-4 w-full bg-slate-600 rounded-full overflow-hidden flex">
                                <div style="width: ${idealPercent}%" class="bg-emerald-400 h-full"></div>
                                <div style="width: ${lostPercent}%" class="bg-amber-400 h-full"></div>
                            </div>
                            <div class="flex justify-between text-[10px] text-slate-500 mt-1">
                                <span>Cruise: ${data.idealTime.toFixed(3)}s</span>
                                <span>Lost: ${(data.realTime - data.idealTime).toFixed(3)}s</span>
                            </div>
                        </div>
                        
                        ${data.jerkSavingsPercent > 5 ? `
                        <div class="mt-3 bg-amber-900/30 text-amber-100 p-2 rounded text-xs border border-amber-700/50 flex items-start gap-2">
                             <i data-lucide="zap" width="14" class="text-amber-400 mt-0.5"></i>
                             <div>
                                <strong>Jerk Bottleneck:</strong> Increasing Jerk by 2x would save <strong>${Math.round(data.jerkSavingsPercent)}%</strong> time on this short move.
                             </div>
                        </div>
                        ` : ''}
                    </div>
                </div>
                `;
            };

            analysisContent.innerHTML = 
                createColumn("Infill", analysis.infill, "layers", THEME_COLORS.primary) +
                createColumn("Wall", analysis.wall, "layers", THEME_COLORS.secondary) +
                createColumn("Travel", analysis.travel, "layers", THEME_COLORS.chartTravel);
        }

        // Start
        init();

    </script>
</body>
</html>
